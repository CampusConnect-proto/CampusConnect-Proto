
/**
 * This ruleset enforces a security model for the Campus Connect platform,
 * which facilitates property and mess rentals for students. The model is designed
 * to be secure while allowing for rapid development and iteration.
 *
 * Core Philosophy:
 * The rules establish a clear separation between public-facing content and
 * private user data. Property, mess, and review information is publicly readable
 * to enable browsing and searching, but all write operations (creating, updating,
 * deleting) are strictly controlled by user ownership. User profiles (for both
 * students and property owners) are private and can only be managed by the
 * owning user.
 *
 * Data Structure:
 * The data is organized into five distinct top-level collections:
 * - /properties: Contains all property listings.
 * - /mess_listings: Contains all mess/tiffin service listings.
 * - /reviews: Contains all reviews for properties.
 * - /students: Contains private student user profiles.
 * - /propertyOwners: Contains private property owner user profiles with a nested
 *   'suggestions' subcollection.
 *
 * Key Security Decisions:
 * - Public Read, Private Write: The `/properties`, `/mess_listings`, and `/reviews`
 *   collections are publicly readable by anyone, including unauthenticated users,
 *   to support the core discovery features of the app. However, creating or
 *   modifying this content is restricted to the authenticated owner.
 * - Strict User Privacy: The `/students` and `/propertyOwners` collections are
 *   private. A user can only access their own document, and listing all users
 *   in the collection is explicitly forbidden to prevent user enumeration.
 * - Nested Suggestions for Security: The `suggestions` from students are stored
 *   in a subcollection under the respective `/propertyOwners/{propertyOwnerId}`.
 *   This is a critical data modeling decision that enables secure, queryable
 *   access. It ensures that an owner can only ever list their own suggestions,
 *   preventing data leakage.
 *
 * Denormalization for Authorization:
 * To ensure fast and simple authorization checks, ownership data is denormalized
 * directly onto the documents being secured.
 * - `Property` documents contain `propertyOwnerId`.
 * - `MessListing` documents contain `ownerId`.
 * - `Review` documents contain a `studentId`.
 *
 * Structural Segregation:
 * User profile data is structurally segregated from public application content.
 * This is a more secure and performant pattern than mixing public and private
 * documents in the same collection. It makes list operations on public collections
 * safe by design.
 */
rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    // -------------------------------------------------------------------------
    // Helper Functions
    // -------------------------------------------------------------------------

    function isSignedIn() {
      return request.auth != null;
    }

    function isOwner(userId) {
      return isSignedIn() && request.auth.uid == userId;
    }

    function isExistingOwner(userId) {
      return isOwner(userId) && resource != null;
    }

    function isNewPropertyOwner(property) {
      return isOwner(property.propertyOwnerId);
    }
    
    function isNewMessOwner(messListing) {
      return isOwner(messListing.ownerId);
    }

    function isNewReviewAuthor(review) {
      return isOwner(review.studentId);
    }
    
    function isNewSuggestionAuthor(suggestion) {
      return isOwner(suggestion.studentId);
    }
    
    function isCreatingOwnProfile(userDocId, userProfile) {
      return isOwner(userDocId) && userProfile.id == userDocId;
    }

    function isIdImmutable(newDoc) {
      return newDoc.id == resource.data.id;
    }
    
    function isPropertyOwnerImmutable(newDoc) {
      return newDoc.propertyOwnerId == resource.data.propertyOwnerId;
    }
    
    function isMessOwnerImmutable(newDoc) {
      return newDoc.ownerId == resource.data.ownerId;
    }

    function isReviewAuthorImmutable(newDoc) {
      return newDoc.studentId == resource.data.studentId;
    }

    function isSuggestionStudentImmutable(newSuggestion) {
      return newSuggestion.studentId == resource.data.studentId;
    }

    // -------------------------------------------------------------------------
    // Collection: properties
    // -------------------------------------------------------------------------
    match /properties/{propertyId} {
      allow get, list: if true;
      allow create: if isSignedIn() && isNewPropertyOwner(request.resource.data);
      allow update: if isExistingOwner(resource.data.propertyOwnerId) && isPropertyOwnerImmutable(request.resource.data);
      allow delete: if isExistingOwner(resource.data.propertyOwnerId);
    }
    
    // -------------------------------------------------------------------------
    // Collection: mess_listings
    // -------------------------------------------------------------------------
    match /mess_listings/{messListingId} {
      allow get, list: if true;
      allow create: if isSignedIn() && isNewMessOwner(request.resource.data);
      allow update: if isExistingOwner(resource.data.ownerId) && isMessOwnerImmutable(request.resource.data);
      allow delete: if isExistingOwner(resource.data.ownerId);
    }

    // -------------------------------------------------------------------------
    // Collection: reviews
    // -------------------------------------------------------------------------
    match /reviews/{reviewId} {
      allow get, list: if true;
      allow create: if isSignedIn() && isNewReviewAuthor(request.resource.data);
      allow update: if isExistingOwner(resource.data.studentId) && isReviewAuthorImmutable(request.resource.data);
      allow delete: if isExistingOwner(resource.data.studentId);
    }

    // -------------------------------------------------------------------------
    // Collection: students
    // -------------------------------------------------------------------------
    match /students/{studentId} {
      allow get: if isOwner(studentId);
      allow list: if false;
      allow create: if isCreatingOwnProfile(studentId, request.resource.data);
      allow update: if isExistingOwner(studentId) && isIdImmutable(request.resource.data);
      allow delete: if isExistingOwner(studentId);
    }

    // -------------------------------------------------------------------------
    // Collection: propertyOwners
    // -------------------------------------------------------------------------
    match /propertyOwners/{propertyOwnerId} {
      allow get: if isOwner(propertyOwnerId);
      allow list: if false;
      allow create: if isCreatingOwnProfile(propertyOwnerId, request.resource.data);
      allow update: if isExistingOwner(propertyOwnerId) && isIdImmutable(request.resource.data);
      allow delete: if isExistingOwner(propertyOwnerId);

      // Subcollection: suggestions
      match /suggestions/{suggestionId} {
        // Owner can read suggestions for their properties. Student who wrote it can also read it.
        allow get: if isOwner(propertyOwnerId) || isOwner(resource.data.studentId);
        // Owner can list all suggestions for their properties.
        allow list: if isOwner(propertyOwnerId);
        // An authenticated student can create a suggestion. Path ensures it's for the right owner.
        allow create: if isNewSuggestionAuthor(request.resource.data);
        // Only the property owner can update the status of a suggestion.
        allow update: if isOwner(propertyOwnerId) && isSuggestionStudentImmutable(request.resource.data);
        // Owner or the original student can delete the suggestion.
        allow delete: if isOwner(propertyOwnerId) || isOwner(resource.data.studentId);
      }
    }
  }
}

    